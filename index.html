<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"/>
<title>Smile Lens</title>

<style>
html,body{
  margin:0;
  padding:0;
  background:#0b0c10;
  overflow:hidden;
  font-family:system-ui,-apple-system,BlinkMacSystemFont,sans-serif;
  color:#eaeaea;
}
video,canvas{
  position:absolute;
  top:0;left:0;
  width:100%;
  height:100%;
  object-fit:cover;
}
#ui{
  position:absolute;
  bottom:28px;
  width:100%;
  text-align:center;
  pointer-events:none;
}
#phrase{
  font-size:16px;
  opacity:0;
  transition:opacity .4s ease;
}
#settingsToggle{
  position:absolute;
  top:14px;
  right:16px;
  opacity:.35;
}
#settingsPanel{
  position:absolute;
  top:52px;
  right:16px;
  background:rgba(20,20,24,.85);
  border-radius:12px;
  padding:10px;
  display:none;
}
select{
  background:#111;
  color:#eee;
  border:none;
  padding:6px;
  border-radius:6px;
}
</style>
</head>

<body>

<video id="video" autoplay muted playsinline></video>
<canvas id="canvas"></canvas>

<div id="settingsToggle">⚙︎</div>
<div id="settingsPanel">
  <select id="lang">
    <option value="en">English</option>
    <option value="pt">Português</option>
    <option value="ru" selected>Русский</option>
  </select>
</div>

<div id="ui"><div id="phrase"></div></div>

<script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

<script>
/* ===== Text ===== */
const TEXT={
  en:{smile:"Natural smile"},
  pt:{smile:"Sorriso natural"},
  ru:{smile:"Естественная улыбка"}
};
let lang="ru";

/* ===== Smile Analysis ===== */
class SmileAnalyzer{
  constructor(){
    this.baseline=null;
    this.ema=0;
    this.alpha=0.15;
    this.t0=performance.now();
    this.holdStart=null;
  }
  update(lm){
    const a=lm[61],b=lm[291];
    const d=Math.hypot(a.x-b.x,a.y-b.y);
    if(!this.baseline && performance.now()-this.t0<700){
      this.baseline=this.baseline?(this.baseline+d)/2:d;
      return{level:0,held:false};
    }
    if(!this.baseline)this.baseline=d;
    this.ema=this.ema?this.ema+this.alpha*(d-this.ema):d;
    const ratio=this.ema/this.baseline;
    const smiling=ratio>=1.12;
    if(smiling){
      if(!this.holdStart)this.holdStart=performance.now();
    }else this.holdStart=null;
    return{
      level:Math.min(Math.max((ratio-1)/0.25,0),1),
      held:this.holdStart&&performance.now()-this.holdStart>1500
    };
  }
}

/* ===== Renderer ===== */
class Renderer{
  constructor(c){
    this.ctx=c.getContext("2d");
    this.resize();
    window.addEventListener("resize",()=>this.resize());
    this.aura=0;
    this.breath=0;
  }
  resize(){
    canvas.width=innerWidth;
    canvas.height=innerHeight;
  }
  clear(){this.ctx.clearRect(0,0,canvas.width,canvas.height);}
  drawAura(x,y,level){
    this.aura+= (level-this.aura)*0.08;
    if(this.aura<0.01)return;
    this.breath+=0.02;
    const r=140+Math.sin(this.breath)*10+this.aura*160;
    const g=this.ctx.createRadialGradient(x,y,r*.3,x,y,r);
    g.addColorStop(0,`rgba(180,200,255,${0.35*this.aura})`);
    g.addColorStop(1,"rgba(180,200,255,0)");
    this.ctx.fillStyle=g;
    this.ctx.beginPath();
    this.ctx.arc(x,y,r,0,Math.PI*2);
    this.ctx.fill();
  }
  drawGlasses(l,r,intensity){
    if(intensity<.2)return;
    this.ctx.strokeStyle=`rgba(230,230,240,${.6*intensity})`;
    this.ctx.lineWidth=2;
    this.ctx.beginPath();
    this.ctx.moveTo(l.x-28,l.y);
    this.ctx.lineTo(r.x+28,r.y);
    this.ctx.stroke();
  }
}

/* ===== UI ===== */
const phrase=document.getElementById("phrase");
const settingsToggle=document.getElementById("settingsToggle");
const settingsPanel=document.getElementById("settingsPanel");
document.getElementById("lang").onchange=e=>lang=e.target.value;
settingsToggle.onclick=()=>settingsPanel.style.display=
  settingsPanel.style.display==="block"?"none":"block";

/* ===== App ===== */
const video=document.getElementById("video");
const canvas=document.getElementById("canvas");
const renderer=new Renderer(canvas);
const analyzer=new SmileAnalyzer();

const mesh=new FaceMesh({
  locateFile:f=>`https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${f}`
});
mesh.setOptions({
  maxNumFaces:1,
  refineLandmarks:true,
  minDetectionConfidence:.6,
  minTrackingConfidence:.6
});

mesh.onResults(r=>{
  renderer.clear();
  if(!r.multiFaceLandmarks){
    phrase.style.opacity=0;
    return;
  }
  const lm=r.multiFaceLandmarks[0];
  const s=analyzer.update(lm);
  const cx=lm[1].x*canvas.width;
  const cy=lm[1].y*canvas.height;
  renderer.drawAura(cx,cy,s.level);
  renderer.drawGlasses(
    {x:lm[33].x*canvas.width,y:lm[33].y*canvas.height},
    {x:lm[263].x*canvas.width,y:lm[263].y*canvas.height},
    s.held?1:s.level
  );
  phrase.textContent=TEXT[lang].smile;
  phrase.style.opacity=s.level>.25?1:0;
});

new Camera(video,{
  facingMode:"user",
  onFrame:async()=>mesh.send({image:video})
}).start();
</script>
</body>
</html>
