<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Face Training – Mirror</title>

<style>
html,body{
  margin:0;
  padding:0;
  height:100%;
  font-family:system-ui,-apple-system,BlinkMacSystemFont,sans-serif;
  background:#eaeaea;
}
#app{height:100%;display:flex}

/* LEFT — reference */
#ref{
  flex:1;
  background:
    linear-gradient(#ddd 1px,transparent 1px),
    linear-gradient(90deg,#ddd 1px,transparent 1px);
  background-size:24px 24px;
  display:flex;
  align-items:center;
  justify-content:center;
}
#ref canvas{width:260px;height:260px}

/* RIGHT — mirror */
#mirror{
  flex:1;
  position:relative;
  background:#000;
}
video,canvas{
  position:absolute;
  inset:0;
  width:100%;
  height:100%;
  object-fit:cover;
}
#phase{
  position:absolute;
  bottom:20px;
  width:100%;
  text-align:center;
  color:#fff;
  font-size:15px;
  opacity:.8;
}
#idle{
  position:absolute;
  inset:0;
  display:flex;
  align-items:center;
  justify-content:center;
  color:#888;
  font-size:16px;
}
.hidden{display:none}
</style>
</head>

<body>
<div id="app">

  <div id="ref">
    <canvas id="refCanvas" width="300" height="300"></canvas>
  </div>

  <div id="mirror">
    <video id="video" autoplay muted playsinline></video>
    <canvas id="overlay"></canvas>
    <div id="idle">Look at yourself</div>
    <div id="phase"></div>
  </div>

</div>

<script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

<script>
/* ---------- STATE ---------- */
let phase="idle"; // idle → demo → perform → hold → rest
let phaseTime=0;
let faceVisible=false;

/* ---------- REFERENCE ---------- */
const refCtx=document.getElementById("refCanvas").getContext("2d");
let demoT=0;

function drawReference(p){
  refCtx.clearRect(0,0,300,300);
  refCtx.strokeStyle="#444";
  refCtx.lineWidth=2;
  refCtx.beginPath();
  refCtx.arc(150,150,90,0,Math.PI*2);
  refCtx.stroke();

  let v=p;
  if(phase==="demo"){
    demoT+=0.04;
    v=(Math.sin(demoT)+1)/2;
  }

  refCtx.strokeStyle="#c44";
  refCtx.beginPath();
  refCtx.arc(150,170,50,0,Math.PI*v);
  refCtx.stroke();
}

/* ---------- SMILE ANALYZER ---------- */
class Smile{
  constructor(){this.base=null;this.ema=0;this.alpha=0.15;this.t0=0;}
  reset(){this.base=null;this.ema=0;this.t0=performance.now();}
  value(lm){
    const L=lm[61],R=lm[291];
    const d=Math.hypot(L.x-R.x,L.y-R.y);
    if(!this.base && performance.now()-this.t0<700){
      this.base=this.base?(this.base+d)/2:d;
      return 0;
    }
    this.base??=d;
    this.ema=this.ema?this.ema+this.alpha*(d-this.ema):d;
    return Math.min(Math.max((this.ema/this.base-1)/0.25,0),1);
  }
}
const smile=new Smile();

/* ---------- CAMERA ---------- */
const video=document.getElementById("video");
const overlay=document.getElementById("overlay");
const octx=overlay.getContext("2d");
const idleEl=document.getElementById("idle");
const phaseEl=document.getElementById("phase");

function resize(){
  overlay.width=overlay.clientWidth;
  overlay.height=overlay.clientHeight;
}
window.addEventListener("resize",resize);
resize();

const mesh=new FaceMesh({
  locateFile:f=>`https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${f}`
});
mesh.setOptions({
  maxNumFaces:1,
  refineLandmarks:true,
  minDetectionConfidence:.6,
  minTrackingConfidence:.6
});

mesh.onResults(r=>{
  octx.clearRect(0,0,overlay.width,overlay.height);

  if(!r.multiFaceLandmarks){
    faceVisible=false;
    phase="idle";
    idleEl.classList.remove("hidden");
    phaseEl.textContent="";
    return;
  }

  faceVisible=true;
  idleEl.classList.add("hidden");

  const lm=r.multiFaceLandmarks[0];
  const p=smile.value(lm);

  // phase machine
  phaseTime++;

  if(phase==="idle"){
    phase="demo";
    phaseTime=0;
    demoT=0;
    smile.reset();
  }else if(phase==="demo" && phaseTime>60){
    phase="perform";
    phaseTime=0;
  }else if(phase==="perform" && p>0.8){
    phase="hold";
    phaseTime=0;
  }else if(phase==="hold" && phaseTime>90){
    phase="rest";
    phaseTime=0;
  }else if(phase==="rest" && phaseTime>60){
    phase="demo";
    phaseTime=0;
    demoT=0;
    smile.reset();
  }

  phaseEl.textContent=
    phase==="demo"?"Watch":
    phase==="perform"?"Do it":
    phase==="hold"?"Hold":
    phase==="rest"?"Rest":"";

  drawReference(p);

  if(phase==="perform"||phase==="hold"){
    const L=lm[61],R=lm[291];
    const x1=L.x*overlay.width;
    const x2=R.x*overlay.width;
    const y=(L.y+R.y)/2*overlay.height;
    octx.strokeStyle=`rgba(255,255,255,${0.3+0.5*p})`;
    octx.lineWidth=3;
    octx.beginPath();
    octx.arc((x1+x2)/2,y,(x2-x1)/2,0,Math.PI);
    octx.stroke();
  }
});

new Camera(video,{
  facingMode:"user",
  onFrame:async()=>mesh.send({image:video})
}).start();
</script>
</body>
</html>
